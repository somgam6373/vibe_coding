//claude

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_N 1000
#define INF 999999

// ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ì˜ ë…¸ë“œ êµ¬ì¡°ì²´
typedef struct AdjNode {
    int vertex;
    struct AdjNode* next;
} AdjNode;

// ê·¸ë˜í”„ êµ¬ì¡°ì²´
typedef struct Graph {
    int numVertices;
    AdjNode** adjList;
} Graph;

// ê·¸ë˜í”„ ì´ˆê¸°í™”
Graph* createGraph(int vertices) {
    Graph* graph = (Graph*)malloc(sizeof(Graph));
    graph->numVertices = vertices;
    graph->adjList = (AdjNode**)malloc((vertices + 1) * sizeof(AdjNode*));
    
    // ëª¨ë“  ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë¥¼ NULLë¡œ ì´ˆê¸°í™” (1ë²ˆë¶€í„° ì‹œì‘í•˜ë¯€ë¡œ vertices+1)
    for (int i = 0; i <= vertices; i++) {
        graph->adjList[i] = NULL;
    }
    
    return graph;
}

// ìƒˆë¡œìš´ ì¸ì ‘ ë…¸ë“œ ìƒì„±
AdjNode* createAdjNode(int vertex) {
    AdjNode* newNode = (AdjNode*)malloc(sizeof(AdjNode));
    newNode->vertex = vertex;
    newNode->next = NULL;
    return newNode;
}

// ë‹¨ë°©í–¥ ê°„ì„  ì¶”ê°€ (ì¤‘ë³µ ë°©ì§€ë¥¼ ìœ„í•´)
void addEdge(Graph* graph, int src, int dest) {
    AdjNode* newNode = createAdjNode(dest);
    newNode->next = graph->adjList[src];
    graph->adjList[src] = newNode;
}

// íŒŒì¼ì—ì„œ ê·¸ë˜í”„ ì½ê¸°
Graph* readGraphFromFile(const char* filename) {
    FILE* file = fopen(filename, "r");
    if (!file) {
        printf("íŒŒì¼ì„ ì—´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: %s\n", filename);
        return NULL;
    }
    
    int numVertices;
    fscanf(file, "%d", &numVertices);
    
    Graph* graph = createGraph(numVertices);
    
    char line[1000];
    fgets(line, sizeof(line), file); // ì²« ì¤„ì˜ ê°œí–‰ë¬¸ì ì²˜ë¦¬
    
    // ê° ì¤„ì„ ì½ì–´ì„œ ì—°ê²° ì •ë³´ íŒŒì‹±
    while (fgets(line, sizeof(line), file)) {
        char* token = strtok(line, " \n");
        if (!token) continue;
        
        int src = atoi(token);
        
        // ë‚˜ë¨¸ì§€ í† í°ë“¤ì€ ì—°ê²°ëœ ë…¸ë“œë“¤
        while ((token = strtok(NULL, " \n")) != NULL) {
            int dest = atoi(token);
            addEdge(graph, src, dest);
        }
    }
    
    fclose(file);
    return graph;
}

// ê·¸ë˜í”„ ì¶œë ¥ (ë””ë²„ê¹…ìš©)
void printGraph(Graph* graph) {
    for (int i = 1; i <= graph->numVertices; i++) {
        printf("%d: ", i);
        AdjNode* temp = graph->adjList[i];
        while (temp) {
            printf("%d ", temp->vertex);
            temp = temp->next;
        }
        printf("\n");
    }
}

// í êµ¬ì¡°ì²´ (BFSìš©)
typedef struct Queue {
    int items[MAX_N];
    int front;
    int rear;
} Queue;

// í ì´ˆê¸°í™”
Queue* createQueue() {
    Queue* q = (Queue*)malloc(sizeof(Queue));
    q->front = -1;
    q->rear = -1;
    return q;
}

// íê°€ ë¹„ì–´ìˆëŠ”ì§€ í™•ì¸
int isEmpty(Queue* q) {
    return q->rear == -1;
}

// íì— ìš”ì†Œ ì¶”ê°€
void enqueue(Queue* q, int value) {
    if (q->rear == MAX_N - 1) {
        printf("íê°€ ê°€ë“ ì°¸\n");
    } else {
        if (q->front == -1) {
            q->front = 0;
        }
        q->rear++;
        q->items[q->rear] = value;
    }
}

// íì—ì„œ ìš”ì†Œ ì œê±°
int dequeue(Queue* q) {
    if (isEmpty(q)) {
        printf("íê°€ ë¹„ì–´ìˆìŒ\n");
        return -1;
    } else {
        int item = q->items[q->front];
        q->front++;
        if (q->front > q->rear) {
            q->front = q->rear = -1;
        }
        return item;
    }
}

// BFSë¡œ ì‹œì‘ ë…¸ë“œì—ì„œ ëª¨ë“  ë…¸ë“œê¹Œì§€ì˜ ê±°ë¦¬ ê³„ì‚°
int* bfs(Graph* graph, int start) {
    int* dist = (int*)malloc((graph->numVertices + 1) * sizeof(int));
    int* visited = (int*)malloc((graph->numVertices + 1) * sizeof(int));
    
    // ì´ˆê¸°í™”
    for (int i = 1; i <= graph->numVertices; i++) {
        dist[i] = INF;
        visited[i] = 0;
    }
    
    Queue* q = createQueue();
    
    dist[start] = 0;
    visited[start] = 1;
    enqueue(q, start);
    
    while (!isEmpty(q)) {
        int current = dequeue(q);
        
        AdjNode* temp = graph->adjList[current];
        while (temp) {
            int neighbor = temp->vertex;
            if (!visited[neighbor]) {
                visited[neighbor] = 1;
                dist[neighbor] = dist[current] + 1;
                enqueue(q, neighbor);
            }
            temp = temp->next;
        }
    }
    
    free(visited);
    free(q);
    return dist;
}

// ë‘ ë…¸ë“œ ê°„ì˜ ìµœë‹¨ ê±°ë¦¬ ê³„ì‚°
int getDistance(Graph* graph, int src, int dest) {
    int* dist = bfs(graph, src);
    int result = dist[dest];
    free(dist);
    return result == INF ? -1 : result;
}

// (1) ë‚˜ì™€ ë„ˆì˜ ê±°ë¦¬ëŠ”? - 67ë²ˆê³¼ 26ë²ˆ ì‚¬ì´ì˜ ê±°ë¦¬
void question1(Graph* graph) {
    int dist = getDistance(graph, 67, 26);
    printf("(1) 67ë²ˆê³¼ 26ë²ˆ ì‚¬ì´ì˜ ê±°ë¦¬: %d\n", dist);
}

// (2) Lone WolfëŠ”? - ì—°ê²°ëœ ì»´í¬ë„ŒíŠ¸ì˜ ìˆ˜ ê³„ì‚°
int countComponents(Graph* graph) {
    int* visited = (int*)malloc((graph->numVertices + 1) * sizeof(int));
    int components = 0;
    
    // ì´ˆê¸°í™”
    for (int i = 1; i <= graph->numVertices; i++) {
        visited[i] = 0;
    }
    
    // ê° ë…¸ë“œì—ì„œ DFS ì‹œì‘
    for (int i = 1; i <= graph->numVertices; i++) {
        if (!visited[i]) {
            // ìƒˆë¡œìš´ ì»´í¬ë„ŒíŠ¸ ë°œê²¬
            components++;
            
            // DFSë¡œ ì—°ê²°ëœ ëª¨ë“  ë…¸ë“œ ë°©ë¬¸ í‘œì‹œ
            int* stack = (int*)malloc(graph->numVertices * sizeof(int));
            int top = 0;
            stack[top] = i;
            
            while (top >= 0) {
                int current = stack[top--];
                if (!visited[current]) {
                    visited[current] = 1;
                    
                    AdjNode* temp = graph->adjList[current];
                    while (temp) {
                        if (!visited[temp->vertex]) {
                            stack[++top] = temp->vertex;
                        }
                        temp = temp->next;
                    }
                }
            }
            free(stack);
        }
    }
    
    free(visited);
    return components;
}

void question2(Graph* graph) {
    int components = countComponents(graph);
    printf("(2) ì—°ê²°ëœ ì»´í¬ë„ŒíŠ¸ ìˆ˜ (Lone Wolf): %d\n", components);
}

// (3) 3ë‹¨ê³„ ì´ë‚´ì— ê°€ì¥ ë§ì€ ì‚¬ëŒì—ê²Œ ë„ë‹¬í•  ìˆ˜ ìˆëŠ” ì‚¬ëŒ
int countReachable(Graph* graph, int start, int maxDist) {
    int* dist = bfs(graph, start);
    int count = 0;
    
    for (int i = 1; i <= graph->numVertices; i++) {
        if (dist[i] <= maxDist) {
            count++;
        }
    }
    
    free(dist);
    return count;
}

void question3(Graph* graph) {
    int bestPerson = 1;
    int maxReachable = 0;
    
    for (int i = 1; i <= graph->numVertices; i++) {
        int reachable = countReachable(graph, i, 3);
        if (reachable > maxReachable) {
            maxReachable = reachable;
            bestPerson = i;
        }
    }
    
    printf("(3) 3ë‹¨ê³„ ì´ë‚´ì— ê°€ì¥ ë§ì€ ì‚¬ëŒ(%dëª…)ì—ê²Œ ë„ë‹¬ ê°€ëŠ¥í•œ ì‚¬ëŒ: %dë²ˆ\n", 
           maxReachable, bestPerson);
}

// (4) 3ë‹¨ê³„ ì´ë‚´ë¡œ ëª¨ë“  ì‚¬ëŒì—ê²Œ ì—°ë½í•˜ê¸° ìœ„í•œ ìµœì†Œ ì¸ì› ì¡°í•©
void question4(Graph* graph) {
    int* covered = (int*)malloc((graph->numVertices + 1) * sizeof(int));
    int* selected = (int*)malloc((graph->numVertices + 1) * sizeof(int));
    int selectedCount = 0;
    
    // ì´ˆê¸°í™”
    for (int i = 1; i <= graph->numVertices; i++) {
        covered[i] = 0;
        selected[i] = 0;
    }
    
    // ê·¸ë¦¬ë”” ë°©ì‹: ë§¤ë²ˆ ê°€ì¥ ë§ì€ ë¯¸ì»¤ë²„ ë…¸ë“œë¥¼ ì»¤ë²„í•˜ëŠ” ë…¸ë“œ ì„ íƒ
    while (1) {
        int bestNode = -1;
        int bestNewCovered = 0;
        
        // ê° ë…¸ë“œì— ëŒ€í•´ ìƒˆë¡œ ì»¤ë²„í•  ìˆ˜ ìˆëŠ” ë…¸ë“œ ìˆ˜ ê³„ì‚°
        for (int i = 1; i <= graph->numVertices; i++) {
            if (selected[i]) continue;
            
            int* dist = bfs(graph, i);
            int newCovered = 0;
            
            for (int j = 1; j <= graph->numVertices; j++) {
                if (!covered[j] && dist[j] <= 3) {
                    newCovered++;
                }
            }
            
            if (newCovered > bestNewCovered) {
                bestNewCovered = newCovered;
                bestNode = i;
            }
            
            free(dist);
        }
        
        if (bestNode == -1 || bestNewCovered == 0) break;
        
        // ì„ íƒëœ ë…¸ë“œë¡œ ì»¤ë²„ ì—…ë°ì´íŠ¸
        selected[bestNode] = 1;
        selectedCount++;
        
        int* dist = bfs(graph, bestNode);
        for (int j = 1; j <= graph->numVertices; j++) {
            if (dist[j] <= 3) {
                covered[j] = 1;
            }
        }
        free(dist);
    }
    
    printf("(4) 3ë‹¨ê³„ ì´ë‚´ ì „ì²´ ì»¤ë²„ë¥¼ ìœ„í•œ ìµœì†Œ ì¸ì›(%dëª…): ", selectedCount);
    for (int i = 1; i <= graph->numVertices; i++) {
        if (selected[i]) {
            printf("%d ", i);
        }
    }
    printf("\n");
    
    free(covered);
    free(selected);
}

// ë©”ì¸ í•¨ìˆ˜
int main() {
    printf("=== ì¼€ë¹ˆ ë² ì´ì»¨ ê²Œì„ ===\n");
    
    // ê·¸ë˜í”„ íŒŒì¼ ì½ê¸°
    Graph* graph = readGraphFromFile("kb.txt");
    if (!graph) {
        printf("ê·¸ë˜í”„ë¥¼ ì½ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n");
        return 1;
    }
    
    printf("ê·¸ë˜í”„ ë¡œë“œ ì™„ë£Œ: %dëª…ì˜ ì‚¬ëŒ\n\n", graph->numVertices);
    
    // 4ê°€ì§€ ì§ˆë¬¸ í•´ê²°
    question1(graph);
    question2(graph);
    question3(graph);
    question4(graph);
    
    // ë©”ëª¨ë¦¬ í•´ì œ
    for (int i = 1; i <= graph->numVertices; i++) {
        AdjNode* temp = graph->adjList[i];
        while (temp) {
            AdjNode* toDelete = temp;
            temp = temp->next;
            free(toDelete);
        }
    }
    free(graph->adjList);
    free(graph);
    
    return 0;
}


/*
í”„ë¡¬í¬íŠ¸
ë„ˆëŠ” Cì–¸ì–´ ì „ë¬¸ê°€ì´ì ê·¸ë˜í”„ ì´ë¡ ì— ëŠ¥ìˆ™í•œ ì•Œê³ ë¦¬ì¦˜ ê°œë°œìì•¼.

ë‚´ê°€ ì œê³µí•˜ëŠ” í…ìŠ¤íŠ¸ íŒŒì¼ì€ ë¬´ë°©í–¥ ê·¸ë˜í”„ í˜•íƒœì˜ ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë¡œ, ì‚¬ëŒ ê°„ì˜ ì—°ê²° ì •ë³´ë¥¼ ë‚˜íƒ€ë‚´. ì´ ê·¸ë˜í”„ë¥¼ ë°”íƒ•ìœ¼ë¡œ "ì¼€ë¹ˆ ë² ì´ì»¨ ê²Œì„"ì„ êµ¬í˜„í•˜ëŠ” C í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•´ ì¤˜.

---

ğŸ”¹ ì…ë ¥ íŒŒì¼: `ì„ì§„ìš± - kb.txt`
- ì²« ì¤„ì€ ë…¸ë“œ(ì‚¬ëŒ)ì˜ ì´ ìˆ˜ N
- ì´í›„ ê° ì¤„ì€ í•´ë‹¹ ë²ˆí˜¸ ì‚¬ëŒì˜ ì—°ê²° ì •ë³´ë¥¼ ë‚˜íƒ€ëƒ„
- ì˜ˆì‹œ:  1 3 6
â†’ 1ë²ˆ ì‚¬ëŒì€ 3ë²ˆ, 6ë²ˆê³¼ ì—°ê²°ë¨

---

ğŸ”¹ êµ¬í˜„ ì¡°ê±´:
1. í…ìŠ¤íŠ¸ íŒŒì¼ì„ ì½ì–´ ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ ê·¸ë˜í”„ë¥¼ êµ¬ì„±
2. ê·¸ë˜í”„ íƒìƒ‰ì€ BFSë¥¼ ì´ìš©í•´ ê° ì‚¬ëŒ ê°„ ìµœì†Œ ê±°ë¦¬ ê³„ì‚°
3. "ì¼€ë¹ˆ ë² ì´ì»¨ ìˆ˜" ê°œë…ì„ ë°˜ì˜í•˜ì—¬ íŠ¹ì • ì¸ë¬¼ ê°„ ê±°ë¦¬ ê³„ì‚°

---

ğŸ”¹ í”„ë¡œê·¸ë¨ì€ ë‹¤ìŒ 4ê°€ì§€ ì§ˆë¬¸ì— ëŒ€í•œ ë‹µì„ ì¶œë ¥í•´ì•¼ í•´:

**(1) ë‚˜ì™€ ë„ˆì˜ ê±°ë¦¬ëŠ”?**
- ì˜ˆ: 1ë²ˆê³¼ 82ë²ˆ ì‚¬ëŒ ê°„ ìµœë‹¨ ê±°ë¦¬ ì¶œë ¥

**(2) Lone WolfëŠ”?**
- ê·¸ë˜í”„ì—ì„œ ì—°ê²°ë˜ì§€ ì•Šì€ ê·¸ë£¹ì´ ëª‡ ê°œì¸ì§€ ì¶œë ¥
- ì¦‰, ì„œë¡œ ì—°ê²°ë˜ì§€ ì•Šì€ ë…ë¦½ì ì¸ ì»´í¬ë„ŒíŠ¸ ìˆ˜ ì¶œë ¥

**(3) 3ë‹¨ê³„ ì´ë‚´ì— ëª¨ë‘ì—ê²Œ ì—°ë½í•˜ë ¤ë©´ ëˆ„êµ¬ì—ê²Œ ì—°ë½í•´ì•¼ í• ê¹Œ?**
- 1ëª…ì˜ ì‚¬ëŒì„ ì„ íƒí•  ìˆ˜ ìˆë‹¤ê³  í•  ë•Œ,
- ê·¸ ì‚¬ëŒìœ¼ë¡œë¶€í„° 3ë‹¨ê³„ ì´ë‚´ì— ê°€ì¥ ë§ì€ ì‚¬ëŒì—ê²Œ ë„ë‹¬í•  ìˆ˜ ìˆëŠ” ì‚¬ëŒì˜ ë²ˆí˜¸ë¥¼ ì¶œë ¥

**(4) 3ë‹¨ê³„ ì´ë‚´ì— ëª¨ë‘ì—ê²Œ ì—°ë½í•˜ë ¤ë©´ ëˆ„êµ¬ ëˆ„êµ¬ì—ê²Œ ì—°ë½í•´ì•¼ í•˜ë‚˜?**
- ìµœì†Œí•œì˜ ì¸ì› ì¡°í•©ì„ ì„ íƒí•´ì„œ ì „ì²´ ì¸ì›ì—ê²Œ 3ë‹¨ê³„ ì´ë‚´ë¡œ ëª¨ë‘ ì „ë‹¬ë˜ë„ë¡ ë§Œë“œëŠ” ì§‘í•©ì„ ì¶œë ¥
- ì˜ˆ: 3ëª…ë§Œ ë½‘ì•„ì„œ ì „ì²´ì— 3ë‹¨ê³„ ì´ë‚´ ì „ë‹¬ ê°€ëŠ¥í•˜ë©´ ê·¸ 3ëª…ì˜ ë²ˆí˜¸ ì¶œë ¥

---

ğŸ”¹ ë°”ì´ë¸Œ ì½”ë”© ìŠ¤íƒ€ì¼ë¡œ ë¶€íƒí•´:
- í”„ë¡œê·¸ë¨ ì „ì²´ë¥¼ í•œ ë²ˆì— ì£¼ì§€ ë§ê³ , 
- 1ë‹¨ê³„: ê·¸ë˜í”„ë¥¼ êµ¬ì¡°ì²´ë¡œ êµ¬í˜„
- 2ë‹¨ê³„: BFSë¡œ ê±°ë¦¬ ì¸¡ì • í•¨ìˆ˜
- 3ë‹¨ê³„: ìœ„ ì§ˆë¬¸ë“¤ì— ëŒ€í•œ í•´ê²° í•¨ìˆ˜
ì´ëŸ° ì‹ìœ¼ë¡œ ë‹¨ê³„ë³„ë¡œ ì„¤ëª…ê³¼ í•¨ê»˜ ì½”ë“œë¥¼ êµ¬ì„±í•´ ì¤˜.

---

ğŸ”¹ ì¶”ê°€ ì œì•½:
- Cì–¸ì–´ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ë§Œ ì‚¬ìš© (stdio.h, stdlib.h ë“±)
- ì™¸ë¶€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì—†ì´ êµ¬í˜„
- ê° ë‹¨ê³„ë§ˆë‹¤ ì½”ë“œ + ê°„ë‹¨í•œ ì„¤ëª… í¬í•¨

ì´ ëª¨ë“  ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” C í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•´ ì¤˜.



*/
